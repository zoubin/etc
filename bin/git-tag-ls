#!/usr/bin/env bash

# 本意是选一段时间，找出其中的版本序列，计算整体迭代的代码量
# 难点在于代码量是两个版本的对比，所选时间段内的第一个版本需要和一个时间段外更早的版本做对比才行，如果没有，就会少算第一个版本的迭代
# git tag-ls "v[0-9]*" --since="2019-03-01" --until "2019-03-31" | pair |xargs -L 1 -J {} git diff-stat {} -- src server packages bin
# git tag-ls "v[0-9]*" --since="2019-03-01" --until "2019-03-31" | pair |xargs -L 1 -I {} sh -c 'git diff-stat {}
# -- ":(exclude)*package-lock.json" ":(exclude)*yarn.lock" ":(exclude)examples/*" ":(exclude)_build/*" ":(exclude)*dist/*" ":(exclude)*.min.*"'

while (( "$#" )); do
  case "$1" in
    --since=*|--after=*)
      from=`echo $1 | cut -c 9-18`
      shift 1
      ;;
    --until=*)
      to=`echo $1 | cut -c 9-18`
      shift 1
      ;;
    --before=*)
      to=`echo $1 | cut -c 10-19`
      shift 1
      ;;
    --since|--after)
      from=$2
      shift 2
      ;;
    --until|--before)
      to=$2
      shift 2
      ;;
    *)
      patterns+=( $1 )
      shift
      ;;
  esac
done

to_filter() {
  if [[ -nz $to ]];then
    src='{ if ($2 <= "'"$to"'") print $0 }'
    awk "$src"
  else
    awk '{print}'
  fi
}

from_filter() {
  if [[ -nz $from ]];then
    src='{
      if ($2 >= "'"$from"'") {
        if (prev) {
          print prev;
          prev = "";
        }
        print $0;
      } else {
        prev = $0;
      }
    }'
    awk "$src"
  else
    awk '{print}'
  fi
}

git tag --sort=taggerdate --format="%(tag) %(taggerdate:short)" -l "${patterns[@]}"\
  | awk '{ if (NF > 1) print}' | to_filter | from_filter | awk '{ print $1 }'
